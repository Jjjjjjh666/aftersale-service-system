<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SnowFlakeIdWorker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">core</a> &gt; <a href="index.source.html" class="el_package">cn.edu.xmu.javaee.core.util</a> &gt; <span class="el_source">SnowFlakeIdWorker.java</span></div><h1>SnowFlakeIdWorker.java</h1><pre class="source lang-java linenums">package cn.edu.xmu.javaee.core.util;

/**
 * Twitter_Snowflake&lt;br&gt;
 * SnowFlake的结构如下(每部分用-分开):&lt;br&gt;
 * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;
 * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br&gt;
 * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)
 * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br&gt;
 * 10位的数据机器位，可以部署在1024个节点，包括3位datacenterId和7位workerId&lt;br&gt;
 * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br&gt;
 * 加起来刚好64位，为一个Long型。&lt;br&gt;
 * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。
 */
/**
 */
public class SnowFlakeIdWorker {

    // ==============================Fields===========================================
    /** 开始时间截 (2015-01-01) */
<span class="nc" id="L21">    private final Long twepoch = 1420041600000L;</span>

    /** 机器id所占的位数 */
<span class="nc" id="L24">    private final static Long workerIdBits = 7L;</span>

    /** 数据标识id所占的位数 */
<span class="nc" id="L27">    private final static Long datacenterIdBits = 3L;</span>

    /** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */
<span class="nc" id="L30">    public final static Long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);</span>

    /** 支持的最大数据标识id，结果是31 */
<span class="nc" id="L33">    public final static Long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits);</span>

    /** 序列在id中占的位数 */
<span class="nc" id="L36">    private final Long sequenceBits = 12L;</span>

    /** 机器ID向左移12位 */
<span class="nc" id="L39">    private final Long workerIdShift = sequenceBits;</span>

    /** 数据标识id向左移17位(12+5) */
<span class="nc" id="L42">    private final Long datacenterIdShift = sequenceBits + workerIdBits;</span>

    /** 时间截向左移22位(5+5+12) */
<span class="nc" id="L45">    private final Long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span>

    /** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */
<span class="nc" id="L48">    private final Long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits);</span>

    /** 工作机器ID(0~31) */
    private Long workerId;

    /** 数据中心ID(0~31) */
    private Long datacenterId;

    /** 毫秒内序列(0~4095) */
<span class="nc" id="L57">    private long sequence = 0L;</span>

    /** 上次生成ID的时间截 */
<span class="nc" id="L60">    private long lastTimestamp = -1L;</span>

    //==============================Constructors=====================================
    /**
     * 构造函数
     * @param workerId 工作ID (0~31)
     * @param datacenterId 数据中心ID (0~31)
     */
<span class="nc" id="L68">    public SnowFlakeIdWorker(Long workerId, Long datacenterId) {</span>
<span class="nc bnc" id="L69" title="All 4 branches missed.">        if (workerId &gt; maxWorkerId || workerId &lt; 0) {</span>
<span class="nc" id="L70">            throw new IllegalArgumentException(String.format(&quot;worker Id can't be greater than %d or less than 0&quot;, maxWorkerId));</span>
        }
<span class="nc bnc" id="L72" title="All 4 branches missed.">        if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) {</span>
<span class="nc" id="L73">            throw new IllegalArgumentException(String.format(&quot;datacenter Id can't be greater than %d or less than 0&quot;, maxDatacenterId));</span>
        }
<span class="nc" id="L75">        this.workerId = workerId;</span>
<span class="nc" id="L76">        this.datacenterId = datacenterId;</span>
<span class="nc" id="L77">    }</span>

    // ==============================Methods==========================================
    /**
     * 获得下一个ID (该方法是线程安全的)
     * @return SnowflakeId
     */
    public Long nextId() {
        

<span class="nc" id="L87">        synchronized (this) {</span>
<span class="nc" id="L88">            Long timestamp = timeGen();</span>
            //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常
<span class="nc bnc" id="L90" title="All 2 branches missed.">            if (timestamp &lt; lastTimestamp) {</span>
<span class="nc" id="L91">                throw new RuntimeException(</span>
<span class="nc" id="L92">                        String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));</span>
            }

            //如果是同一时间生成的，则进行毫秒内序列
<span class="nc bnc" id="L96" title="All 2 branches missed.">            if (lastTimestamp == timestamp) {</span>
<span class="nc" id="L97">                sequence = (sequence + 1) &amp; sequenceMask;</span>
                //毫秒内序列溢出
<span class="nc bnc" id="L99" title="All 2 branches missed.">                if (sequence == 0) {</span>
                    //阻塞到下一个毫秒,获得新的时间戳
<span class="nc" id="L101">                    timestamp = tilNextMillis(lastTimestamp);</span>
                }
            }
            //时间戳改变，毫秒内序列重置
            else {
<span class="nc" id="L106">                sequence = 0L;</span>
            }

            //上次生成ID的时间截
<span class="nc" id="L110">            lastTimestamp = timestamp;</span>
        

        //移位并通过或运算拼到一起组成64位的ID
<span class="nc" id="L114">            return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) //</span>
<span class="nc" id="L115">                    | (datacenterId &lt;&lt; datacenterIdShift) //</span>
<span class="nc" id="L116">                    | (workerId &lt;&lt; workerIdShift) //</span>
                    | sequence;
            }
        }
    /**
     * 阻塞到下一个毫秒，直到获得新的时间戳
     * @param lastTimestamp 上次生成ID的时间截
     * @return 当前时间戳
     */
    protected Long tilNextMillis(Long lastTimestamp) {
<span class="nc" id="L126">        long timestamp = timeGen();</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        while (timestamp &lt;= lastTimestamp) {</span>
<span class="nc" id="L128">            timestamp = timeGen();</span>
        }
<span class="nc" id="L130">        return timestamp;</span>
    }

    /**
     * 返回以毫秒为单位的当前时间
     * @return 当前时间(毫秒)
     */
    protected Long timeGen() {
<span class="nc" id="L138">        return System.currentTimeMillis();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>